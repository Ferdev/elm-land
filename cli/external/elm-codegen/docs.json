[{"name":"Elm","comment":"\n\n@docs File, file\n\n\n## Basics\n\n@docs Expression\n\n@docs bool, int, float, char, string, hex, unit\n\n@docs maybe, just, nothing\n\n@docs list, tuple, triple\n\n@docs withType, withAlias\n\n\n## Records\n\n@docs record, field, Field, get, updateRecord\n\n\n## Flow control\n\n@docs letIn, ifThen\n\n\n## Top level\n\n@docs Declaration\n\n@docs comment, declaration\n\n@docs withDocumentation\n\n@docs expose, exposeWith\n\n@docs fileWith, docs\n\n\n## Functions\n\n@docs fn, fn2, fn3, fn4, fn5, fn6, function, functionReduced\n\n\n## Custom Types\n\n@docs customType, Variant, variant, variantWith\n\n@docs alias\n\n\n# Operators\n\n@docs equal, notEqual\n\n@docs append, cons\n\n@docs plus, minus, multiply, divide, intDivide, power\n\n@docs lt, gt, lte, gte, and, or\n\n\n## Parsing\n\n@docs keep, skip\n\n\n## Url parsing\n\n@docs slash, query\n\n\n# Ports\n\n@docs portIncoming, portOutgoing\n\n\n# Parsing existing Elm\n\n@docs parse, unsafe\n\n\n# Rendering to string\n\n@docs toString, signature, expressionImports\n\n@docs declarationToString, declarationImports\n\n\n# Low-level\n\n@docs apply, value\n\n@docs unwrap, unwrapper\n\n","unions":[{"name":"Field","comment":" ","args":[],"cases":[]},{"name":"Variant","comment":" ","args":[],"cases":[]}],"aliases":[{"name":"Declaration","comment":" ","args":[],"type":"Internal.Compiler.Declaration"},{"name":"Expression","comment":" ","args":[],"type":"Internal.Compiler.Expression"},{"name":"File","comment":" ","args":[],"type":"{ path : String.String, contents : String.String }"}],"values":[{"name":"alias","comment":" A custom type declaration.\n\n    import Elm.Annotation as Type\n\n    Elm.alias \"MyAlias\"\n        (Type.record\n            [ ( \"one\", Type.string )\n            , ( \"two\", Type.int )\n            , ( \"three\", Type.var \"content\" )\n            ]\n        )\n\nShould result in\n\n    type alias MyAlias content =\n        { one : String\n        , two : Int\n        , three : content\n        }\n\n","type":"String.String -> Elm.Annotation.Annotation -> Elm.Declaration"},{"name":"and","comment":" `&&`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"append","comment":" `++`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"apply","comment":" ","type":"Elm.Expression -> List.List Elm.Expression -> Elm.Expression"},{"name":"bool","comment":" ","type":"Basics.Bool -> Elm.Expression"},{"name":"char","comment":" ","type":"Char.Char -> Elm.Expression"},{"name":"comment","comment":" ","type":"String.String -> Elm.Declaration"},{"name":"cons","comment":" `::`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"customType","comment":" A custom type declaration.\n\n    Elm.customType \"MyType\"\n        [ Elm.variant \"One\"\n        , Elm.variantWith \"Two\"\n            [ Elm.Annotation.list Elm.Annotation.string ]\n        ]\n\nWill result in\n\n    type MyType\n        = One\n        | Two (List String)\n\n","type":"String.String -> List.List Elm.Variant -> Elm.Declaration"},{"name":"declaration","comment":" ","type":"String.String -> Elm.Expression -> Elm.Declaration"},{"name":"declarationImports","comment":" ","type":"Elm.Declaration -> String.String"},{"name":"declarationToString","comment":" ","type":"Elm.Declaration -> String.String"},{"name":"divide","comment":" `/`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"docs","comment":" Render a standard docstring.\n\n    @docs one, two, three\n\nIf a `group` has been given, it will be rendered as a second level header.\n\n```markdown\n## Group name\n\n@docs one, two, three\n```\n\n","type":"{ group : Maybe.Maybe String.String, members : List.List String.String } -> String.String"},{"name":"equal","comment":" `==`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"expose","comment":" By default, everything is exposed for your module.\n\nHowever, you can tag specific declarations you want exposed, and then only those things will be exposed.\n\n","type":"Elm.Declaration -> Elm.Declaration"},{"name":"exposeWith","comment":" You can also add a group tag to an exposed value. This will automatically group the `docs` statements in the module docs.\n\nFor precise control over what is rendered for the module comment, use [fileWith](#fileWith)\n\n","type":"{ exposeConstructor : Basics.Bool, group : Maybe.Maybe String.String } -> Elm.Declaration -> Elm.Declaration"},{"name":"expressionImports","comment":" ","type":"Elm.Expression -> String.String"},{"name":"field","comment":" ","type":"String.String -> Elm.Expression -> Elm.Field"},{"name":"file","comment":" Build a file!\n\n    Elm.file [ \"My\", \"Module\" ]\n        [ Elm.declaration \"placeholder\"\n            (Elm.string \"a fancy string!\")\n        ]\n\n","type":"List.List String.String -> List.List Elm.Declaration -> Elm.File"},{"name":"fileWith","comment":" Same as [file](#file), but you have more control over how the module comment is generated!\n\nPass in a function that determines how to render a `@doc` comment.\n\nEach exposed item is grouped based on the string used in [exposeWith](#exposeWith).\n\n**aliases** allow you to specify a module alias to be used.\n\n    aliases =\n        [ ([\"Json\", \"Encode\"), \"Encode\")\n        ]\n\nwould make an import statement like\n\n    import Json.Encode as Encode\n\nAll values rendered in this file that are from this module would also automatically respect this alias as well.\n\n","type":"List.List String.String -> { docs : List.List { group : Maybe.Maybe String.String, members : List.List String.String } -> List.List String.String, aliases : List.List ( List.List String.String, String.String ) } -> List.List Elm.Declaration -> Elm.File"},{"name":"float","comment":" ","type":"Basics.Float -> Elm.Expression"},{"name":"fn","comment":" Create a function with a single argument.\n\nThis may seem a little weird the first time you encounter it, so let's break it down.\n\nHere's what's happening for the `fn*` functions —\n\n  - The `String` arguments are the **names of the arguments** for the generated function.\n  - The `(Expression -> Expression)` function is where we're providing you an `Expression` that represents an argument coming in to the generated function.\n\nSo, this\n\n    Elm.fn \"firstInt\"\n        (\\firstArgument ->\n            Elm.plus\n                (Elm.int 42)\n                firstArgument\n        )\n\nGenerates\n\n    \\firstInt -> 42 + firstInt\n\nIf you want to generate a **top level** function instead of an anonymous function, use `Elm.declaration`.\n\n    Elm.declaration \"add42\" <|\n        Elm.fn \"firstInt\"\n            (\\firstArgument ->\n                Elm.plus\n                    (Elm.int 42)\n                    firstArgument\n            )\n\nResults in\n\n    add42 : Int -> Int\n    add42 firstInt =\n        42 + firstInt\n\n**Note** — Elm CodeGen will protect variable names if they're used in a nested `fn*` by adding a string of numbers to the end of the name. So, you may see a variable name be something like `myVariable_0_1`.\n\nIf you absolutely don't want this behavior, you'll need to use [`functionAdvanced`](#functionAdvanced).\n\n**Another Note** — There may be situations where `elm-codegen` is unable to infer the type of one of the parameters. This is especially the case if you are using type aliases.\n\nIn this case you can use [`withType`](#withType) to manually attach a type to a value. That looks like this:\n\n    import Elm\n    import Elm.Annotation\n\n    Elm.fn \"firstInt\"\n        (\\firstArgument ->\n            (firstArgument\n                |> Elm.withType\n                    (Elm.Annotation.named [\"MyOwnModule\"] \"MyCustomType\")\n            )\n        )\n\n","type":"String.String -> (Elm.Expression -> Elm.Expression) -> Elm.Expression"},{"name":"fn2","comment":" ","type":"String.String -> String.String -> (Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Expression"},{"name":"fn3","comment":" ","type":"String.String -> String.String -> String.String -> (Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Expression"},{"name":"fn4","comment":" ","type":"String.String -> String.String -> String.String -> String.String -> (Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Expression"},{"name":"fn5","comment":" ","type":"String.String -> String.String -> String.String -> String.String -> String.String -> (Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Expression"},{"name":"fn6","comment":" ","type":"String.String -> String.String -> String.String -> String.String -> String.String -> String.String -> (Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Expression"},{"name":"function","comment":" You may run into situations where you don't know the number of arguments for a function at compile-time.\n\nIn that case you can use `function`. It follows the same pattern as the `fn*` functions.\n\nProvide it with —\n\n  - A list of argument names and an optional type\n  - A function which will be given all the input arguments as `Expression`s.\n\n","type":"List.List ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> (List.List Elm.Expression -> Elm.Expression) -> Elm.Expression"},{"name":"functionReduced","comment":" This is a special case of function declaration which will _reduce_ itself if possible.\n\nMeaning, if this would generate the following code\n\n    \\myArg -> someOtherFunction myArg\n\nThen it will replace itself with just\n\n    someOtherFunction\n\n**Note** you likely won't need this! It's generally used by the package-helper generator, but that might be a relatively special case.\n\n","type":"String.String -> (Elm.Expression -> Elm.Expression) -> Elm.Expression"},{"name":"get","comment":"\n\n    record\n        |> Elm.get \"field\"\n\nresults in\n\n    record.field\n\n","type":"String.String -> Elm.Expression -> Elm.Expression"},{"name":"gt","comment":" `>`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"gte","comment":" `>=`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"hex","comment":" ","type":"Basics.Int -> Elm.Expression"},{"name":"ifThen","comment":"\n\n    ifThen (Elm.bool True)\n        (Elm.string \"yes\")\n        (Elm.string \"no\")\n\nWill generate\n\n    if True then\n        \"yes\"\n\n    else\n        \"no\"\n\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"int","comment":" ","type":"Basics.Int -> Elm.Expression"},{"name":"intDivide","comment":" `//`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"just","comment":" ","type":"Elm.Expression -> Elm.Expression"},{"name":"keep","comment":" used in the `elm/parser` library\n\n`|=`\n\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"letIn","comment":" A let block.\n\n    import Elm\n\n\n    Elm.letIn\n        [ (\"one\", (Elm.int 5))\n        , (\"two\", (Elm.int 10))\n        ]\n        (Elm.add (Elm.value \"one\") (Elm.value \"two\"))\n\n","type":"List.List ( String.String, Elm.Expression ) -> Elm.Expression -> Elm.Expression"},{"name":"list","comment":" ","type":"List.List Elm.Expression -> Elm.Expression"},{"name":"lt","comment":" `<`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"lte","comment":" `<=`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"maybe","comment":" ","type":"Maybe.Maybe Elm.Expression -> Elm.Expression"},{"name":"minus","comment":" `-`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"multiply","comment":" `*`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"notEqual","comment":" `/=`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"nothing","comment":" ","type":"Elm.Expression"},{"name":"or","comment":" `||`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"parse","comment":" ","type":"String.String -> Result.Result String.String { declarations : List.List Elm.Declaration }"},{"name":"plus","comment":" `+`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"portIncoming","comment":"\n\n    import Elm.Annotation as Type\n\n    Elm.portIncoming \"receiveMessageFromTheWorld\"\n        [ Type.string\n        , Type.int\n        ]\n\nResults in\n\n    port receiveMessageFromTheWorld :\n        (String -> Int -> msg)\n        -> Sub msg\n\n**Note** You generally only need one incoming and one outgoing port!\n\nIf you want to vary the messages going in and out of your app, don't use a huge number of ports, instead write Json encoders and decoders.\n\nThis will give you more flexibility in the future and save you having to wire up a bunch of stuff.\n\n**Another note** - You may need to expose your port explicitly using `Elm.expose`\n\n","type":"String.String -> List.List Elm.Annotation.Annotation -> Elm.Declaration"},{"name":"portOutgoing","comment":" Create a port that can send messages to the outside world!\n\n    import Elm.Annotation as Type\n\n    Elm.portOutgoing \"tellTheWorld\" Type.string\n\nwill generate\n\n    port tellTheWorld : String -> Cmd msg\n\n","type":"String.String -> Elm.Annotation.Annotation -> Elm.Declaration"},{"name":"power","comment":" The to-the-power-of operator `^`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"query","comment":" `<?>` used in url parsing\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"record","comment":"\n\n    Elm.record\n        [ Elm.field \"name\" (Elm.string \"Elm\")\n        , Elm.field \"designation\" (Elm.string \"Pretty fabulous\")\n        ]\n\n","type":"List.List Elm.Field -> Elm.Expression"},{"name":"signature","comment":" ","type":"Elm.Expression -> String.String"},{"name":"skip","comment":" `|.`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"slash","comment":" `</>` used in url parsing\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"string","comment":" ","type":"String.String -> Elm.Expression"},{"name":"toString","comment":" ","type":"Elm.Expression -> String.String"},{"name":"triple","comment":" ","type":"Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"tuple","comment":" ","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"unit","comment":" ","type":"Elm.Expression"},{"name":"unsafe","comment":" ","type":"String.String -> Elm.Declaration"},{"name":"unwrap","comment":" Unwraps a single-variant type\n\n    Elm.declaration \"myFunction\" <|\n        Elm.fn \"val\"\n            (\\\\val ->\n                Elm.unwrap \"MyType\" val\n            )\n\nResults in the following lambda\n\n    myFunction val =\n        ((MyType val) -> val) val\n\n","type":"List.List String.String -> String.String -> Elm.Expression -> Elm.Expression"},{"name":"unwrapper","comment":" Generate a lambda which unwraps a single-variant type.\n\n    Elm.unwrapper [ \"MyModule\" ] \"MyType\"\n\nResults in the following lambda\n\n    \\(MyModule.MyType val) -> val\n\n**Note** This needs to be a type with only a single variant\n\n","type":"List.List String.String -> String.String -> Elm.Expression"},{"name":"updateRecord","comment":" ","type":"Elm.Expression -> List.List Elm.Field -> Elm.Expression"},{"name":"value","comment":" ","type":"{ importFrom : List.List String.String, name : String.String, annotation : Maybe.Maybe Elm.Annotation.Annotation } -> Elm.Expression"},{"name":"variant","comment":" ","type":"String.String -> Elm.Variant"},{"name":"variantWith","comment":" ","type":"String.String -> List.List Elm.Annotation.Annotation -> Elm.Variant"},{"name":"withAlias","comment":" ","type":"List.List String.String -> String.String -> List.List Elm.Annotation.Annotation -> Elm.Expression -> Elm.Expression"},{"name":"withDocumentation","comment":" Add a documentation comment to a declaration!\n","type":"String.String -> Elm.Declaration -> Elm.Declaration"},{"name":"withType","comment":" Sometimes you may need to add a manual type annotation.\n\n    import Elm.Annotation as Type\n\n    Elm.value \"myString\"\n        |> Elm.withType Type.string\n\nThough be sure `elm-codegen` isn't already doing this automatically for you!\n\n","type":"Elm.Annotation.Annotation -> Elm.Expression -> Elm.Expression"}],"binops":[]},{"name":"Elm.Annotation","comment":"\n\n@docs Annotation, var, bool, int, float, string, char, unit\n\n@docs named, namedWith\n\n@docs maybe, list, tuple, triple, set, dict, result\n\n@docs record, extensible, alias\n\n@docs function\n\n@docs toString\n\n","unions":[],"aliases":[{"name":"Annotation","comment":" ","args":[],"type":"Internal.Compiler.Annotation"}],"values":[{"name":"alias","comment":" ","type":"List.List String.String -> String.String -> List.List Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"bool","comment":" ","type":"Elm.Annotation.Annotation"},{"name":"char","comment":" ","type":"Elm.Annotation.Annotation"},{"name":"dict","comment":" ","type":"Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"extensible","comment":" ","type":"String.String -> List.List ( String.String, Elm.Annotation.Annotation ) -> Elm.Annotation.Annotation"},{"name":"float","comment":" ","type":"Elm.Annotation.Annotation"},{"name":"function","comment":" ","type":"List.List Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"int","comment":" ","type":"Elm.Annotation.Annotation"},{"name":"list","comment":" ","type":"Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"maybe","comment":" ","type":"Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"named","comment":" ","type":"List.List String.String -> String.String -> Elm.Annotation.Annotation"},{"name":"namedWith","comment":" ","type":"List.List String.String -> String.String -> List.List Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"record","comment":" ","type":"List.List ( String.String, Elm.Annotation.Annotation ) -> Elm.Annotation.Annotation"},{"name":"result","comment":" ","type":"Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"set","comment":" ","type":"Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"string","comment":" ","type":"Elm.Annotation.Annotation"},{"name":"toString","comment":" ","type":"Elm.Annotation.Annotation -> String.String"},{"name":"triple","comment":" ","type":"Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"tuple","comment":" ","type":"Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"unit","comment":" ","type":"Elm.Annotation.Annotation"},{"name":"var","comment":" A type variable\n","type":"String.String -> Elm.Annotation.Annotation"}],"binops":[]},{"name":"Elm.Case","comment":"\n\n@docs maybe, result, list\n\n@docs tuple, triple\n\n@docs custom\n\n@docs Branch, otherwise, branch0, branch1, branch2, branch3, branch4, branch5, branch6\n\n@docs branchWith, listBranch\n\n","unions":[{"name":"Branch","comment":" ","args":[],"cases":[]}],"aliases":[],"values":[{"name":"branch0","comment":" ","type":"List.List String.String -> String.String -> Elm.Expression -> Elm.Case.Branch"},{"name":"branch1","comment":" ","type":"List.List String.String -> String.String -> (Elm.Expression -> Elm.Expression) -> Elm.Case.Branch"},{"name":"branch2","comment":" ","type":"List.List String.String -> String.String -> (Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Case.Branch"},{"name":"branch3","comment":" ","type":"List.List String.String -> String.String -> (Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Case.Branch"},{"name":"branch4","comment":" ","type":"List.List String.String -> String.String -> (Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Case.Branch"},{"name":"branch5","comment":" ","type":"List.List String.String -> String.String -> (Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Case.Branch"},{"name":"branch6","comment":" ","type":"List.List String.String -> String.String -> (Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Case.Branch"},{"name":"branchWith","comment":" ","type":"List.List String.String -> String.String -> Basics.Int -> (List.List Elm.Expression -> Elm.Expression) -> Elm.Case.Branch"},{"name":"custom","comment":"\n\n    Elm.fn \"maybeString\" <|\n        \\maybeString ->\n            Elm.Case.custom maybeString\n                [ Elm.Case.branch [ \"Maybe\" ]\n                    \"Nothing\"\n                    (Elm.string \"It's nothing, I swear!\")\n                , Elm.Case.branch2 [ \"Maybe\" ] \"Just\" <|\n                    \\just ->\n                        Elm.append (Elm.string \"Actually, it's: \") just\n                ]\n\nGenerates\n\n    \\maybeString ->\n        case maybeString of\n            Nothing ->\n                \"It's nothing, I swear!\"\n\n            Just just ->\n                \"Actually, it's \" ++ just\n\n","type":"Elm.Expression -> List.List Elm.Case.Branch -> Elm.Expression"},{"name":"list","comment":"\n\n    Elm.fn \"myList\" <|\n        \\myList ->\n            Elm.Case.list myList\n                { empty = Elm.int 0\n                , nonEmpty =\n                    \\top remaining ->\n                        Elm.plus (Elm.int 5) top\n                }\n\nGenerates\n\n    \\myList ->\n        case myList of\n            [] ->\n                0\n\n            top :: remaining ->\n                top + 5\n\n","type":"Elm.Expression -> { empty : Elm.Expression, nonEmpty : Elm.Expression -> Elm.Expression -> Elm.Expression } -> Elm.Expression"},{"name":"listBranch","comment":" ","type":"Basics.Int -> (List.List Elm.Expression -> Elm.Expression) -> Elm.Case.Branch"},{"name":"maybe","comment":"\n\n    Elm.fn \"myMaybe\" <|\n        \\myMaybe ->\n            Elm.Case.maybe myMaybe\n                { nothing = Elm.int 0\n                , just =\n                    \\content ->\n                        Elm.plus (Elm.int 5) content\n                }\n\nGenerates\n\n    \\myMaybe ->\n        case myMaybe of\n            Nothing ->\n                0\n\n            Just just ->\n                just + 5\n\n","type":"Elm.Expression -> { nothing : Elm.Expression, just : Elm.Expression -> Elm.Expression } -> Elm.Expression"},{"name":"otherwise","comment":" A catchall branch in case you want the case to be nonexhaustive.\n","type":"(Elm.Expression -> Elm.Expression) -> Elm.Case.Branch"},{"name":"result","comment":"\n\n    Elm.fn \"myResult\" <|\n        \\myResult ->\n            Elm.Case.triple myResult\n                { ok =\n                    \\ok ->\n                        Elm.string \"No errors\"\n                , err =\n                    \\err ->\n                        err\n                }\n\nGenerates\n\n    \\myResult ->\n        case myResult of\n            Ok ok ->\n                \"No errors\"\n\n            Err err ->\n                err\n\n","type":"Elm.Expression -> { err : Elm.Expression -> Elm.Expression, ok : Elm.Expression -> Elm.Expression } -> Elm.Expression"},{"name":"triple","comment":"\n\n    Elm.fn \"myTriple\" <|\n        \\myTriple ->\n            Elm.Case.triple myTriple\n                { nothing = Elm.int 0\n                , just =\n                    \\one two three ->\n                        Elm.plus (Elm.int 5) two\n                }\n\nGenerates\n\n    \\myTriple ->\n        case myTriple of\n            ( one, two, three ) ->\n                5 + two\n\n","type":"Elm.Expression -> (Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Expression"},{"name":"tuple","comment":"\n\n    Elm.fn \"myTuple\" <|\n        \\myTuple ->\n            Elm.Case.tuple myTuple\n                { nothing = Elm.int 0\n                , just =\n                    \\one two ->\n                        Elm.plus (Elm.int 5) two\n                }\n\nGenerates\n\n    \\myTuple ->\n        case myTuple of\n            ( one, two ) ->\n                5 + two\n\n","type":"Elm.Expression -> (Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Expression"}],"binops":[]},{"name":"Elm.Let","comment":"\n\n@docs letIn\n\n@docs value, tuple, record\n\n@docs toExpression\n\n","unions":[],"aliases":[],"values":[{"name":"letIn","comment":" ","type":"a -> Elm.Let.Let a"},{"name":"record","comment":" ","type":"List.List String.String -> Elm.Expression -> Elm.Let.Let (List.List Elm.Expression -> a) -> Elm.Let.Let a"},{"name":"toExpression","comment":" ","type":"Elm.Let.Let Elm.Expression -> Elm.Expression"},{"name":"tuple","comment":" ","type":"String.String -> String.String -> Elm.Expression -> Elm.Let.Let (( Elm.Expression, Elm.Expression ) -> a) -> Elm.Let.Let a"},{"name":"value","comment":" ","type":"String.String -> Elm.Expression -> Elm.Let.Let (Elm.Expression -> a) -> Elm.Let.Let a"}],"binops":[]}]